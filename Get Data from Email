# returns string w/o leading or trailing whitespace
trim <- function (x) gsub("^\\s+|\\s+$", "", x)

readEnron <- function( rootPath ){
  
  setwd( rootPath )
  if( file.exists("date.csv")) file.remove("date.csv")
  if( file.exists("message.csv")) file.remove("message.csv")
  if( file.exists("to.csv")) file.remove("to.csv")
  if( file.exists("from.csv")) file.remove("from.csv")
  if( file.exists("subject.csv")) file.remove("subject.csv")
  
  #generate a list of all of the emails starting at the root directory
  genlist <- list.files(all.files = TRUE, full.names = TRUE, recursive = TRUE )
  
  # create CVS files to capture the data
  df <- file("date.csv","w")
  mf <- file("message.csv","w")
  tf <- file("to.csv","w")
  ff <- file("from.csv","w")
  sf <- file("subject.csv","w")
  nl <- file("netList.csv","w")
  
  # proces all of the emails in the directory
  for ( email in genlist ) {
    print( email)

    # open the email file
    ef <- file(email,"r")
    
    # read everything
    emailContents <- readLines( ef )
    
    # scan each line for the appropriate tag
    fromIndex <- regexpr("^From:", emailContents)
    toIndex <- regexpr("^To:", emailContents)
    dateIndex <- regexpr("^Date:", emailContents)
    subjectIndex <- regexpr("^Subject:", emailContents)
    messageIDIndex <- regexpr("^Message-ID:", emailContents)
    
    
    #find the lines that have the data requested
    i <- which(dateIndex > -1 )[1]
    k <- which(messageIDIndex >  -1)[1]
    l <- which(fromIndex > -1 )[1]
    j <- which(toIndex > -1 )[1]
    m <- which(subjectIndex > -1 )[1]
  
    # was there a To: tag specified and was it before the Subject: tag
    # if not ignore the email
    if((  is.na( j ) != TRUE ) && (m > j) && (m > l)) {
      # yes, then process the email
      dateAttr <- substr( emailContents[i], 7 ,5000)
      messageIDAttr <- substr( emailContents[k], 13 ,5000)
      subjectAttr <- substr( emailContents[m], 10 ,5000)
      fromAttr <- substr( emailContents[l], 7 ,5000)
      fromAttr <- gsub("e-mail <.","", fromAttr)
      fromAttr <- gsub(">","",fromAttr)
      
      # paste all of the lines between the to and subject tags, because there are multiple
      # recipients
      emailLines <- ""
      loop <- j
      while ( loop < m ) {
        emailLines <- paste( emailLines, emailContents[loop], sep="" )
        loop <- loop + 1
      }
  
      toAttr <- substr( emailLines, 5 ,5000)
      toAttr <- gsub("e-mail <.","", toAttr)
      toAttr <- gsub(">","",toAttr)
      
      # write data to CSV files each line should be for the same entry across the files
      writeLines(dateAttr, df)
      writeLines(messageIDAttr, mf)
      writeLines(fromAttr, ff)
      writeLines(toAttr, tf)
      writeLines(subjectAttr, sf)
      genNetList <- unlist(strsplit(toAttr,split=","))
      for ( listIndex in 1:length(genNetList) ){
        if( regexpr("enron.com", genNetList[listIndex]) > 2 ){
          writeLines( paste( trim(fromAttr), trim(genNetList[listIndex]), sep=","), nl )
        }
      }
  #  } else {
  #    writeLines("skipping ",ff)
    }
    close( ef )
  }
  close(df)
  close(mf)
  close(ff)
  close(tf)
  close(sf)
  close(nl)
  
}

buildMatrix <- function( fromCsv, toCSV ){
  enronEmailSenders <- read.csv( fromCsv, header = FALSE, sep="," )
  ll <- unique.data.frame(enronEmailSenders, incomparables = FALSE,fromLast = FALSE)
  qq <- unlist(ll, use.names = FALSE)
  fromIndex <- regexpr("enron.com$", qq)
  sendList <- list()
  totalItems <- nrow(ll)
  for ( index in 1:totalItems ) {
    if((!is.na(fromIndex[index]) && ( fromIndex[index] > 1 )) ){
      ii <- length( sendList )
      ww <- ll[index,1]
      sendList[ii + 1] <- ll[index,2]
      print( ll[index,1]  )
    }
  }
    
  
  return( sendList )
}

startpath <- "c:/Users/miltony/Documents/BigData/EnronSubset"
readEnron( startpath )
fromCsv <- "from.csv"
toCSV <- "to.csv"
#enronEmail <- buildMatrix(fromCsv, toCSV)
#enronEmailSenders <- readLines("From.csv")
#uniqueEnronEmailSender<-unique(sort(enronEmailSenders))
#lenEEmail <-length(uniqueEnronEmailSender)
#emailConnectivity = buildMatrix(fromCsv, toCSV )

