# returns string w/o leading or trailing whitespace
trim <- function (x) gsub("^\\s+|\\s+$", "", x)

readEnron <- function( rootPath ){
  
  setwd( rootPath )
  if( file.exists("date.csv")) file.remove("date.csv")
  if( file.exists("message.csv")) file.remove("message.csv")
  if( file.exists("to.csv")) file.remove("to.csv")
  if( file.exists("from.csv")) file.remove("from.csv")
  if( file.exists("subject.csv")) file.remove("subject.csv")
  
  #generate a list of all of the emails starting at the root directory
  genlist <- list.files(all.files = TRUE, full.names = TRUE, recursive = TRUE )
  
  # create CVS files to capture the data
  df <- file("date.csv","w")
  mf <- file("message.csv","w")
  tf <- file("to.csv","w")
  ff <- file("from.csv","w")
  sf <- file("subject.csv","w")
  nl <- file("netList.csv","w")
  
  # proces all of the emails in the directory
  for ( email in genlist ) {
    print( email)
    
    # open the email file
    ef <- file(email,"r")
    
    # read everything
    emailContents <- readLines( ef )
    
    # scan each line for the appropriate tag
    fromIndex <- regexpr("^From:", emailContents)
    toIndex <- regexpr("^To:", emailContents)
    dateIndex <- regexpr("^Date:", emailContents)
    subjectIndex <- regexpr("^Subject:", emailContents)
    messageIDIndex <- regexpr("^Message-ID:", emailContents)
    
    
    #find the lines that have the data requested
    i <- which(dateIndex > -1 )[1]
    k <- which(messageIDIndex >  -1)[1]
    l <- which(fromIndex > -1 )[1]
    j <- which(toIndex > -1 )[1]
    m <- which(subjectIndex > -1 )[1]
    
    # was there a To: tag specified and was it before the Subject: tag
    # if not ignore the email
    if((  is.na( j ) != TRUE ) && (m > j) && (m > l)) {
      # yes, then process the email
      dateAttr <- substr( emailContents[i], 7 ,5000)
      messageIDAttr <- substr( emailContents[k], 13 ,5000)
      subjectAttr <- substr( emailContents[m], 10 ,5000)
      fromAttr <- substr( emailContents[l], 7 ,5000)
      fromAttr <- gsub("e-mail <.","", fromAttr)
      fromAttr <- gsub(">","",fromAttr)
      
      # paste all of the lines between the to and subject tags, because there are multiple
      # recipients
      emailLines <- ""
      loop <- j
      while ( loop < m ) {
        emailLines <- paste( emailLines, emailContents[loop], sep="" )
        loop <- loop + 1
      }
      
      toAttr <- substr( emailLines, 5 ,5000)
      toAttr <- gsub("e-mail <.","", toAttr)
      toAttr <- gsub(">","",toAttr)
      
      # write data to CSV files each line should be for the same entry across the files
      writeLines(dateAttr, df)
      writeLines(messageIDAttr, mf)
      writeLines(fromAttr, ff)
      writeLines(toAttr, tf)
      writeLines(subjectAttr, sf)
      genNetList <- unlist(strsplit(toAttr,split=","))
      for ( listIndex in 1:length(genNetList) ){
        if( regexpr("enron.com", genNetList[listIndex]) > 2 ){
          writeLines( paste( trim(fromAttr), trim(genNetList[listIndex]), sep=","), nl )
        }
      }
      #  } else {
      #    writeLines("skipping ",ff)
    }
    close( ef )
  }
  close(df)
  close(mf)
  close(ff)
  close(tf)
  close(sf)
  close(nl)
  
}

buildMatrix <- function( fromCsv, toCSV ){
  enronEmailSenders <- read.csv( fromCsv, header = FALSE, sep="," )
  ll <- unique.data.frame(enronEmailSenders, incomparables = FALSE,fromLast = FALSE)
  qq <- unlist(ll, use.names = FALSE)
  fromIndex <- regexpr("enron.com$", qq)
  sendList <- list()
  totalItems <- nrow(ll)
  for ( index in 1:totalItems ) {
    if((!is.na(fromIndex[index]) && ( fromIndex[index] > 1 )) ){
      ii <- length( sendList )
      ww <- ll[index,1]
      sendList[ii + 1] <- ll[index,2]
      print( ll[index,1]  )
    }
  }
  
  
  return( sendList )
}

startpath <- "c:/Users/miltony/Documents/BigData/EnronSubset"
readEnron( startpath )
fromCsv <- "from.csv"
toCSV <- "to.csv"
#enronEmail <- buildMatrix(fromCsv, toCSV)
#enronEmailSenders <- readLines("From.csv")
#uniqueEnronEmailSender<-unique(sort(enronEmailSenders))
#lenEEmail <-length(uniqueEnronEmailSender)
#emailConnectivity = buildMatrix(fromCsv, toCSV )
### read netList document into my computer 
email <-read.csv("/Users/yimanzhang/Desktop/netList.csv",head=F)
#gsub("*.@","", email[,1])
colnames(email) <- c("from", "to")
w <- email[grep("@enron.com", email[,1]),]
newemail <- w[grep("@enron.com",w[,2]),]
dim(w)
dim(email)
dim(newemail)
#write.csv(w,"w.csv")
#write.csv(newemail,"newemail.csv")
#unique(unlist(strsplit(as.character(newemail[,1]),"@"))[seq(2,length(newemail[,2]),2)])
#unique(unlist(strsplit(as.character(newemail[,2]),"@"))[seq(2,length(newemail[,2]),2)])
tail(newemail)
fromname <- gsub("@enron.com", "",newemail[,1])
length(fromname)
toname <- gsub("@enron.com", "",newemail[,2])
length(toname)
uniquename <- unique(c(fromname, toname))
class(uniquename)
n <- length(unique(c(fromname, toname)))
namelist <- cbind(fromname, toname)
head(namelist)
class(namelist)
mat <- matrix(0,n,n)
colnames(mat) <- uniquename
rownames(mat) <- uniquename
head(mat)
mat[namelist] <- 1
dim(namelist)
##remove rowsum<20 and colsum<20
rowcount <- rowSums(mat)
head(rowcount)
colcount <- colSums(mat)
head(colcount)
wwr <- which(rowcount>=13)
wwl <- which(colcount>=13)
n1 <- intersect(wwr, wwl) #fine the columnes and rows which are both bigger or equal to 2 
length(n1)
mat1 <- mat[n1,n1]
dim(mat1)
##remove rowsum==0 and colsum==0
rowcount1 <- rowSums(mat1)
rowcount1
colcount1 <- colSums(mat1)
colcount1
wwr1 <- which(rowcount1==0)
wwl1 <- which(colcount1==0)
n2 <- intersect(wwr1, wwl1) #fine the columnes and rows which are both bigger or equal to 2 
length(n2)
mat2 <- mat1[-n2,-n2]
rowSums(mat2)
colSums(mat2)
##remove loop
diag(mat2) <- 0
o <- which(rownames(mat2)=="chris.germany")
oo <- which(rownames(mat2)=="sara.shackleton")
ooo <- which(rownames(mat2)=="susan.bailey")
oooo <- which(rownames(mat2)=="tana.jones")
mat3 <- mat2[-c(o,oo,ooo,oooo),-c(o,oo,ooo,oooo)]
mat3
dim(mat3)

##build the graph
library(igraph)
g <- graph.adjacency(mat3,mode="directed")
plot(g)

##names of the selected person
rownames(mat3)

##outdegree of each person
outdgree <- rowSums(mat3)
as.matrix(outdgree)
##indgree of each person
indgree <- colSums(mat3)
as.matrix(indgree)
##degree
indegreeG <- degree(g, mode="in")
outdegreeG <- degree(g, mode="out")

##number of edges
rows <- sum(rowSums(mat3))
rows #edges
cols <- sum(colSums(mat3))
cols

##centrality
centrality <- rowSums(mat3)/(dim(mat3)[1]-1)
which(centrality==max(rowSums(mat3)/(dim(mat3)[1]-1)))
as.matrix(centrality)

##betweeness
betweenness <- betweenness(g)
as.matrix(betweenness)

##prestige
prestige <- colSums(mat3)/(dim(mat3)[1]-1)
as.matrix(prestige)

### maximum path length
w <- rownames(mat3)
library(igraph)
### to find the maximum path length
d <- function(x){
  dfs(g,root=x, "out",dist=T)$dist
}
distance <- sapply(w,d)
length <- as.matrix(apply(distance, 2, max))
length
### which vertex has the maximum path length
findpeople <- w[which(length==max(length))]
findpeople

##the first path
path <- distance[,findpeople]
x1 <- path[,1]
as.matrix(x1)
## interested in branches
x1[duplicated(path[,1])]
## the first branch
p1 <- w[which(x1==4)]
p1
###  find all the connections
f <- function(x){
  w[which(mat3[x,]==1)]
}
###  find all the possible way for the first branch
sapply(p1,f)
### find all the possible way for the second branch compare with the possible for the first branch 
p2 <- w[which(x1==5)]
sapply(p2,f)
p3 <- w[which(x1==6)]
sapply(p3,f)
p4 <- w[which(x1==9)]
sapply(p4,f)
p5 <- w[which(x1==10)]
sapply(p5,f)
x2 <- path[,2]
as.matrix(x2)
x2[duplicated(path[,2])]
p1 <- w[which(x2==4)]
p1
sapply(p1,f)


p2 <- w[which(x2==5)]
sapply(p2,f)
p3 <- w[which(x2==6)]
sapply(p3,f)
p4 <- w[which(x2==9)]
sapply(p4,f)
p5 <- w[which(x2==10)]
sapply(p5,f)
p6 <- w[which(x2==11)]
sapply(p6,f)

